#! /usr/bin/env python

import argparse
import struct
import sys
import re
import os
from itertools import chain, zip_longest, groupby
import fnmatch
import time

import umodbus.exceptions

REGISTER_RE = re.compile('([cdhi]@)?(\d*)(/[^:|]*)?([:|].*)?')


def flatmap(f, items):
    return chain.from_iterable(map(f, items))


def grouper(iterable, n, fillvalue=None):
    "Collect data into fixed-length chunks or blocks"
    # grouper('ABCDEFG', 3, 'x') --> ABC DEF Gxx"
    args = [iter(iterable)] * n
    return zip_longest(*args, fillvalue=fillvalue)


def fail(fmt, *args):
    print(fmt.format(args))
    sys.exit(1)


def dump(xs):
    return ' '.join('{:02x}'.format(x) for x in xs)


class Access:
    def __init__(self, name, modbus_type, write, address, pack_type, value=None, presenter=None):
        self.names = [name]
        self.modbus_type = modbus_type
        self.write = write
        self.addresses = [address]
        self.pack_types = [pack_type]
        self.presenters = [presenter]
        if self.write:
            self.values = [value]
        else:
            self.values = None

    def address(self):
        return self.addresses[0]

    def pack_type(self):
        return self.pack_types[0]

    def presenter(self):
        return self.presenters[0]

    def endianness(self):
        return self.pack_type()[0]

    def size(self):
        total = 0
        for p in self.pack_types:
            size = struct.calcsize(p)
            if self.modbus_type in ('h', 'i'):
                assert size % 2 == 0
                size //= 2

            total += size

        return total

    def operations(self):
        if self.write:
            return zip(self.pack_types, self.values)
        else:
            return self.pack_types

    def append(self, other):
        self.names.extend(other.names)
        self.pack_types.extend(other.pack_types)
        self.addresses.extend(other.addresses)
        self.presenters.extend(other.presenters)
        if self.write:
            self.values.extend(other.values)

    def labels(self):
        return (name or address for (name, address) in zip(self.names, self.addresses))

    def print_values(self, definitions):
        for label, value, presenter in zip(self.labels(), self.values, self.presenters):
            if len(value) == 1:
                value = value[0]
            print("{}: {} {}".format(label, value, self.present_value(value, presenter, definitions)))

    def present_value(self, value, presenter, definitions):
        if type(value) != int:
            return ''

        presentation = [hex(value)]

        if presenter:
            if presenter[0] == ':':
                presentation.append(definitions.presenters[presenter][value])
            elif presenter[0] == '|':
                names = []
                for bit, name in definitions.presenters[presenter].items():
                    if value & (1 << bit):
                        names.append(name)
                presentation.append(' | '.join(names))

        return ' '.join(presentation)

    def read_registers_send(self, modbus):
        if self.modbus_type in 'cd':
            n_registers = 0
            for pack_type in self.pack_types:
                n_registers += struct.calcsize(pack_type)
        else:
            n_bytes = 0

            for pack_type in self.pack_types:
                n_bytes += struct.calcsize(pack_type)
                assert n_bytes % 2 == 0

            n_registers = n_bytes // 2

        reader = {
                'c': 'read_coils',
                'd': 'read_discrete_inputs',
                'h': 'read_holding_registers',
                'i': 'read_input_registers',
                }[self.modbus_type]

        self.request = getattr(modbus.protocol, reader)(modbus.slave_id, self.address(), n_registers)

        if args.verbose:
            print('→ <', dump(self.request), '>')

        modbus.send(self.request)

    def read_registers_receive(self, modbus):
        try:
            words = modbus.receive(self.request)
        except umodbus.exceptions.IllegalDataAddressError:
            self.values = ('Invalid address', )
            return
        except umodbus.exceptions.IllegalFunctionError:
            self.values = ('Invalid modbus type', )
            return

        if args.verbose:
            print('←', words)

        if self.modbus_type in 'cd':
            self.values = [[w] for w in words]
        else:
            packed = struct.pack('>{}H'.format(len(words)), *words)

            self.values = []

            for pack in self.pack_types:
                size = struct.calcsize(pack)
                self.values.append(struct.unpack(pack, packed[:size]))
                packed = packed[size:]

    def write_registers(self, modbus):
        if self.modbus_type == 'c':
            values = [v[1] for v in self.values]  # drop the pack type
            if len(values) == 1:
                # TODO validate value, should be boolean
                message = modbus.protocol.write_single_coil(modbus.slave_id, self.address, int(values[0]))
            else:
                raise "Multiple coil write not implemented yet."
        else:
            words = []

            for pack_type, value in zip(self.pack_types, self.values):
                n_bytes = struct.calcsize(pack_type)
                assert n_bytes % 2 == 0

                if 'f' in pack_type or 'd' in pack_type:
                    value = float(value)
                else:
                    value = int(value, 0)

                words.extend([h << 8 | l for h, l in grouper(struct.pack(pack_type, value), 2)])

            message = modbus.protocol.write_multiple_registers(modbus.slave_id, self.address(), words)

        if args.verbose:
            print('→ <', dump(message), '>')

        return modbus.send(message)

    def __repr__(self):
        return "{}@{}/{}{}".format(self.modbus_type,
                                   self.address(),
                                   self.pack_types,
                                   "={}".format(self.values) if self.write else "")


def by_type(access):
    return (access.modbus_type, access.write, access.endianness())


def by_address(access):
    return access.address()


def group_accesses(accesses):
    grouped = []

    for (modbus_type, write, _), xs in groupby(sorted(accesses, key=by_type), key=by_type):
        xs = sorted(xs, key=by_address)
        while len(xs):
            first = xs.pop(0)
            while len(xs):
                second = xs[0]
                if first.address() + first.size() == second.address():
                    first.append(second)
                    xs.pop(0)
                else:
                    break
            grouped.append(first)

    return grouped


def parse_access(register, name, write, value):
    modbus_type, address, pack_type, presenter = re.match(REGISTER_RE, register).groups()

    if not address:
        print("{!r} is not a known named register nor a valid register definition. Skipping it.".format(register))
        return None

    if not modbus_type:
        modbus_type = 'h'
    else:
        modbus_type = modbus_type[:-1]

    if not pack_type:
        if modbus_type in 'cd':
            pack_type = 'B'
        else:
            pack_type = '!H'
    else:
        pack_type = pack_type[1:]

    address = int(address)

    if pack_type[0] not in '@=<>!':
        pack_type = '!' + pack_type

    modbus_type = modbus_type.lower()
    if modbus_type not in 'cdhi':
        fail("Invalid Modbus type '{}'. Valid ones are 'cdhi'", modbus_type)
    if write and modbus_type not in 'ch':
        fail("Invalid Modbus type '{}'. Only coils and holding registers are writable", modbus_type)

    return Access(name, modbus_type, write, address, pack_type, value, presenter)


def parse_accesses(s, definitions):
    accesses = []

    for access in s:
        parts = access.split('=')
        if len(parts) == 1:
            register = parts[0]
            value = None
            write = False
        else:
            register, value = parts
            write = True

        if re.fullmatch(REGISTER_RE, register):
            access = parse_access(register, None, write, value)
            if access:
                accesses.append(access)
        else:
            register_re = re.compile(fnmatch.translate(register))
            for name, definition in definitions.registers.items():
                if register_re.match(name):
                    access = parse_access(definition, name, write, value)
                    if access:
                        accesses.append(access)

    return accesses


class Definitions:
    def __init__(self):
        self.registers = {}
        self.presenters = {}

    def parse(self, filenames):
        for filename in filenames:
            if filename:
                with open(filename) as f:
                    accumulated_line = ''
                    for line in f:
                        if line[0].isspace():
                            accumulated_line += line
                        else:
                            self.parse_line(accumulated_line)
                            accumulated_line = line
                    self.parse_line(accumulated_line)

    def parse_line(self, line):
        if not line:
            return

        line = line.split('#')[0]

        if line[0] in ':|':
            name, values = self.parse_presenter(line)
            self.presenters[name] = values
        else:
            parts = line.split()
            if len(parts) == 2:
                name, definition = parts

                if REGISTER_RE.match(definition):
                    self.registers[name] = definition
                else:
                    print("Invalid definition {!r} for register {!r}. Skipping it".format(definition, name))

    def parse_presenter(self, line):
        parts = line.split()

        name = parts[0]

        values = {}
        for definition in parts[1:]:
            value, symbol = definition.split('=')

            values[int(value, 0)] = symbol

        return name, values


def connect_to_device(args):
    if args.device[0] == '/':
        modbus = ModbusRtu(args.device, args.baud, args.stop_bits, args.slave_id)
    else:
        port = 502
        parts = args.device.split(':')
        if len(parts) == 2:
            host, port = parts
        elif len(parts) == 1:
            host = parts[0]
        else:
            fail("Invalid device {}", args.device)

        if host == '':
            host = 'localhost'

        port = int(port)

        modbus = ModbusTcp(host, port, args.slave_id)

    modbus.connect()

    return modbus


class ModbusTcp:
    def __init__(self, host, port, slave_id):
        self.host = host
        self.port = port
        if not slave_id:
            slave_id = 255
        self.slave_id = slave_id

        import umodbus.client.tcp as modbus
        self.protocol = modbus

    def connect(self):
        import socket
        self.connection = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.connection.settimeout(5)
        self.connection.connect((self.host, self.port))

    def send(self, request):
        self.connection.send(request)

    def receive(self, request):
        header = self.receive_n(6)
        seq, _, count = struct.unpack('>3H', header)
        response = header + self.receive_n(count)

        if args.verbose:
            print('← <', dump(response), '>', len(response), 'bytes')

        return self.protocol.parse_response_adu(response, request)

    def receive_n(self, n):
        data = bytes()
        while len(data) < n:
            len_before = len(data)
            data += self.connection.recv(n - len(data))
            if len(data) == len_before:
                time.sleep(0.1)
        return data

    def close(self):
        self.connection.close()

    def perform_accesses(self, accesses):
        accesses = group_accesses(accesses)

        for access in accesses:
            if access.write:
                access.write_registers(self)
            else:
                access.read_registers_send(self)

        for access in accesses:
            if not access.write:
                access.read_registers_receive(self)
                access.print_values(definitions)

        return self


class ModbusRtu:
    def __init__(self, device, baud, stop_bits, slave_id):
        self.device = device
        self.baud = baud
        self.stop_bits = stop_bits
        if not slave_id:
            slave_id = 1
        self.slave_id = slave_id

        import umodbus.client.serial.rtu as modbus
        self.protocol = modbus

    def connect(self):
        from serial import Serial, PARITY_NONE

        self.connection = Serial(port=self.device, baudrate=self.baud, parity=PARITY_NONE,
                                 stopbits=self.stop_bits, bytesize=8, timeout=5)

    def send(self, request):
        self.connection.write(request)

    def receive(self, request):
        response = self.connection.read(2)
        if len(response) != 2:
            raise RuntimeError("timeout")
        slave_id, function = response

        if function == 3:
            response += self.connection.read(1)
            count = 2 + response[-1]
            response += self.connection.read(count)

        if args.verbose:
            print('← <', dump(response), '>', len(response), 'bytes')

        return self.protocol.parse_response_adu(response, request)

    def close(self):
        self.connection.close()

    def perform_accesses(self, accesses):
        accesses = group_accesses(accesses)

        for access in accesses:
            if access.write:
                access.write_registers(self)
            else:
                access.read_registers_send(self)
                access.read_registers_receive(self)
                access.print_values(definitions)

        return self


parser = argparse.ArgumentParser()
parser.add_argument('-r', '--registers', action='append', default=[])
parser.add_argument('-s', '--slave-id', type=int)
parser.add_argument('-b', '--baud', type=int, default=19200)
parser.add_argument('-p', '--stop-bits', type=int, default=1)
parser.add_argument('-v', '--verbose', action='store_true')
parser.add_argument('device')
parser.add_argument('access', nargs='+')
args = parser.parse_args()

definitions = Definitions()
definitions.parse(args.registers + os.environ.get('MODBUS_DEFINITIONS', '').split(':'))

connect_to_device(args).perform_accesses(parse_accesses(args.access, definitions)).close()

